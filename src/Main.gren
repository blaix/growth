module Main exposing (main)

import Array exposing (Array)
import Bytes
import Db
import Db.Decode
import Dict exposing (Dict)
import HttpClient
import HttpServer exposing (Request, Server)
import HttpServer.Response as Response exposing (Response)
import Init
import Node exposing (Environment)
import Math
import Rule exposing (Rule, RuleId)
import Time
import Stream.Log
import Task
import Transmutable.Html as H exposing (Html)
import Transmutable.Html.Attributes as A
import Url


main : Node.Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = subscriptions
        }



-- MODEL


type alias Model =
    { server : Maybe Server
    , port_ : Int
    , ws4sqlPort : Int
    , env : Node.Environment
    , dbConnection : Db.Connection
    }


type alias Config =
    { port_ : Int
    , ws4sqlPort : Int
    }


defaultConfig : Config
defaultConfig =
    { port_ = 3000
    , ws4sqlPort = 12321
    }


parseArgs : Array String -> Config
parseArgs args =
    Array.foldl parseArg { config = defaultConfig, pendingFlag = Nothing } args
        |> .config


parseArg :
    String
    -> { config : Config, pendingFlag : Maybe String }
    -> { config : Config, pendingFlag : Maybe String }
parseArg arg state =
    when state.pendingFlag is
        Just "--port" ->
            { config =
                { state.config
                    | port_ = String.toInt arg |> Maybe.withDefault state.config.port_
                }
            , pendingFlag = Nothing
            }

        Just "--ws4sql-port" ->
            { config =
                { state.config
                    | ws4sqlPort = String.toInt arg |> Maybe.withDefault state.config.ws4sqlPort
                }
            , pendingFlag = Nothing
            }

        Just _ ->
            { state | pendingFlag = Nothing }

        Nothing ->
            if arg == "--port" || arg == "--ws4sql-port" then
                { state | pendingFlag = Just arg }
            else
                state



-- INIT


init : Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await HttpServer.initialize <| \serverPermission ->
    Init.await HttpClient.initialize <| \httpClientPermission ->
        let
            config =
                parseArgs env.args

            dbConnection =
                Db.init httpClientPermission
                    ("http://localhost:" ++ String.fromInt config.ws4sqlPort ++ "/growth")

            serverConfig =
                { host = "0.0.0.0"
                , port_ = config.port_
                }
        in
        Node.startProgram
            { model =
                { server = Nothing
                , port_ = config.port_
                , ws4sqlPort = config.ws4sqlPort
                , env = env
                , dbConnection = dbConnection
                }
            , command =
                Cmd.batch
                    [ initializeSchema dbConnection
                        |> Task.attempt SchemaInitialized
                    , HttpServer.createServer serverPermission serverConfig
                        |> Task.attempt GotServer
                    ]
            }



-- SCHEMA


initializeSchema : Db.Connection -> Task.Task Db.Error {}
initializeSchema connection =
    Db.execute connection
        { statement = """
              CREATE TABLE IF NOT EXISTS rules (
                  id INTEGER PRIMARY KEY AUTOINCREMENT,
                  rule TEXT NOT NULL,
                  step INTEGER NOT NULL
              )
              """
        , parameters = []
        }
        |> Task.andThen (\_ -> getColumnNames connection)
        |> Task.andThen (runMigrations connection)


getColumnNames : Db.Connection -> Task.Task Db.Error (Array String)
getColumnNames connection =
    Db.getAll connection
        { query = "PRAGMA table_info(rules)"
        , parameters = []
        , decoder = Db.Decode.field Db.Decode.string "name" Db.Decode.succeed
        }


runMigrations : Db.Connection -> Array String -> Task.Task Db.Error {}
runMigrations connection columns =
    let
        hasColumn name =
            Array.any (\col -> col == name) columns

        migrations =
            Array.keepIf (\m -> m.needed)
                [ { needed = hasColumn "step" && not (hasColumn "interval")
                  , statement = "ALTER TABLE rules RENAME COLUMN step TO interval"
                  }
                , { needed = not (hasColumn "last_seen") && not (hasColumn "show_again")
                  , statement = "ALTER TABLE rules ADD COLUMN show_again INTEGER NOT NULL DEFAULT 0"
                  }
                , { needed = hasColumn "last_seen" && not (hasColumn "show_again")
                  , statement = "ALTER TABLE rules RENAME COLUMN last_seen TO show_again"
                  }
                ]
    in
    if Array.isEmpty migrations then
        Task.succeed {}

    else
        Db.transaction connection
            (Array.map (\m -> { statement = m.statement, parameters = [] }) migrations)
            |> Task.map (\_ -> {})



-- MSG


type Msg
    = GotServer (Result HttpServer.ServerError Server)
    | GotRequest { request : Request, response : Response }
    | SchemaInitialized (Result Db.Error {})
    | GotRules { response : Response, result : Result Db.Error (Array Rule) }
    | GotRule { response : Response, ruleId : String, result : Result Db.Error (Maybe Rule) }
    | GotNextDueRule { response : Response, result : Result Db.Error (Maybe Rule) }
    | RuleCreated { response : Response, result : Result Db.Error {} }
    | RuleUpdated { response : Response, result : Result Db.Error {} }
    | RuleDeleted { response : Response, result : Result Db.Error {} }
    | RuleMarkedGood { response : Response, result : Result Db.Error {} }
    | RuleMarkedAgain { response : Response, result : Result Db.Error {} }



-- UPDATE


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    when msg is
        GotServer result ->
            when result is
                Ok server ->
                    { model = { model | server = Just server }
                    , command =
                        model.port_
                            |> String.fromInt
                            |> String.prepend "Server started on port "
                            |> Stream.Log.line model.env.stdout
                            |> Task.execute
                    }

                Err (HttpServer.ServerError error) ->
                    { model = model
                    , command =
                        "Failed to start server: "
                            ++ error.message
                            |> Stream.Log.line model.env.stderr
                            |> Task.map (\_ -> Node.exitWithCode 1)
                            |> Task.executeCmd
                    }

        SchemaInitialized result ->
            when result is
                Ok _ ->
                    { model = model
                    , command =
                        Stream.Log.line model.env.stdout "Database schema initialized"
                            |> Task.execute
                    }

                Err error ->
                    { model = model
                    , command =
                        "Failed to initialize schema: "
                            ++ Db.errorToString error
                            |> Stream.Log.line model.env.stderr
                            |> Task.execute
                    }

        GotRequest { request, response } ->
            handleRequest model request response

        GotRules { response, result } ->
            when result is
                Ok rules ->
                    { model = model
                    , command = sendHtml response (rulesListPage rules)
                    }

                Err error ->
                    { model = model
                    , command = sendError response 500 ("Database error: " ++ Db.errorToString error)
                    }

        GotRule { response, ruleId, result } ->
            when result is
                Ok maybeRule ->
                    when maybeRule is
                        Just rule ->
                            { model = model
                            , command = sendHtml response (editRulePage rule)
                            }

                        Nothing ->
                            { model = model
                            , command = sendError response 404 ("Rule not found: " ++ ruleId)
                            }

                Err error ->
                    { model = model
                    , command = sendError response 500 ("Database error: " ++ Db.errorToString error)
                    }

        RuleCreated { response, result } ->
            when result is
                Ok _ ->
                    { model = model
                    , command = redirect response "/rules"
                    }

                Err error ->
                    { model = model
                    , command = sendError response 500 ("Failed to create rule: " ++ Db.errorToString error)
                    }

        RuleUpdated { response, result } ->
            when result is
                Ok _ ->
                    { model = model
                    , command = redirect response "/rules"
                    }

                Err error ->
                    { model = model
                    , command = sendError response 500 ("Failed to update rule: " ++ Db.errorToString error)
                    }

        RuleDeleted { response, result } ->
            when result is
                Ok _ ->
                    { model = model
                    , command = redirect response "/rules"
                    }

                Err error ->
                    { model = model
                    , command = sendError response 500 ("Failed to delete rule: " ++ Db.errorToString error)
                    }

        GotNextDueRule { response, result } ->
            when result is
                Ok maybeRule ->
                    { model = model
                    , command = sendHtml response (homePage maybeRule)
                    }

                Err error ->
                    { model = model
                    , command = sendError response 500 ("Database error: " ++ Db.errorToString error)
                    }

        RuleMarkedGood { response, result } ->
            when result is
                Ok _ ->
                    { model = model
                    , command = redirect response "/"
                    }

                Err error ->
                    { model = model
                    , command = sendError response 500 ("Failed to mark rule: " ++ Db.errorToString error)
                    }

        RuleMarkedAgain { response, result } ->
            when result is
                Ok _ ->
                    { model = model
                    , command = redirect response "/"
                    }

                Err error ->
                    { model = model
                    , command = sendError response 500 ("Failed to mark rule: " ++ Db.errorToString error)
                    }



-- ROUTING


handleRequest : Model -> Request -> Response -> { model : Model, command : Cmd Msg }
handleRequest model request response =
    when Array.dropFirst 1 (String.split "/" request.url.path) is
        [ "" ] ->
            { model = model
            , command =
                Time.now
                    |> Task.andThen (\now -> Rule.getNextDueRule model.dbConnection now)
                    |> Task.attempt (\result -> GotNextDueRule { response = response, result = result })
            }

        [ "rules" ] ->
            when request.method is
                HttpServer.GET ->
                    { model = model
                    , command =
                        Rule.getAllRules model.dbConnection
                            |> Task.attempt (\result -> GotRules { response = response, result = result })
                    }

                HttpServer.POST ->
                    handleCreateRule model request response

                _ ->
                    { model = model
                    , command = sendError response 405 "Method not allowed"
                    }

        [ "rules", idStr, "edit" ] ->
            when request.method is
                HttpServer.GET ->
                    when String.toInt idStr is
                        Just id ->
                            { model = model
                            , command =
                                Rule.getRule model.dbConnection (Rule.ruleIdFromInt id)
                                    |> Task.attempt (\result -> GotRule { response = response, ruleId = idStr, result = result })
                            }

                        Nothing ->
                            { model = model
                            , command = sendError response 400 "Invalid rule ID"
                            }

                _ ->
                    { model = model
                    , command = sendError response 405 "Method not allowed"
                    }

        [ "rules", idStr, "delete" ] ->
            when request.method is
                HttpServer.POST ->
                    when String.toInt idStr is
                        Just id ->
                            { model = model
                            , command =
                                Rule.deleteRule model.dbConnection (Rule.ruleIdFromInt id)
                                    |> Task.attempt (\result -> RuleDeleted { response = response, result = result })
                            }

                        Nothing ->
                            { model = model
                            , command = sendError response 400 "Invalid rule ID"
                            }

                _ ->
                    { model = model
                    , command = sendError response 405 "Method not allowed"
                    }

        [ "rules", idStr, "good" ] ->
            when request.method is
                HttpServer.POST ->
                    when String.toInt idStr is
                        Just id ->
                            { model = model
                            , command =
                                Time.now
                                    |> Task.andThen (\now -> Rule.markRuleGood model.dbConnection now (Rule.ruleIdFromInt id))
                                    |> Task.attempt (\result -> RuleMarkedGood { response = response, result = result })
                            }

                        Nothing ->
                            { model = model
                            , command = sendError response 400 "Invalid rule ID"
                            }

                _ ->
                    { model = model
                    , command = sendError response 405 "Method not allowed"
                    }

        [ "rules", idStr, "again" ] ->
            when request.method is
                HttpServer.POST ->
                    when String.toInt idStr is
                        Just id ->
                            { model = model
                            , command =
                                Time.now
                                    |> Task.andThen (\now -> Rule.markRuleAgain model.dbConnection now (Rule.ruleIdFromInt id))
                                    |> Task.attempt (\result -> RuleMarkedAgain { response = response, result = result })
                            }

                        Nothing ->
                            { model = model
                            , command = sendError response 400 "Invalid rule ID"
                            }

                _ ->
                    { model = model
                    , command = sendError response 405 "Method not allowed"
                    }

        [ "rules", idStr ] ->
            when request.method is
                HttpServer.POST ->
                    handleUpdateRule model idStr request response

                _ ->
                    { model = model
                    , command = sendError response 405 "Method not allowed"
                    }

        _ ->
            { model = model
            , command = sendError response 404 "Not found"
            }



-- FORM HANDLERS


handleCreateRule : Model -> Request -> Response -> { model : Model, command : Cmd Msg }
handleCreateRule model request response =
    let
        formData =
            request.body
                |> Bytes.toString
                |> Maybe.withDefault ""
                |> parseFormData

        maybeRule =
            Dict.get "rule" formData

        maybeInterval =
            Dict.get "interval" formData
                |> Maybe.andThen String.toInt
    in
    when { rule = maybeRule, interval = maybeInterval } is
        { rule = Just rule, interval = Just interval } ->
            { model = model
            , command =
                Time.now
                    |> Task.andThen (\now -> Rule.createRule model.dbConnection now { rule = rule, interval = interval })
                    |> Task.attempt (\result -> RuleCreated { response = response, result = result })
            }

        _ ->
            { model = model
            , command = sendError response 400 "Missing required fields: rule and interval"
            }


handleUpdateRule : Model -> String -> Request -> Response -> { model : Model, command : Cmd Msg }
handleUpdateRule model idStr request response =
    let
        formData =
            request.body
                |> Bytes.toString
                |> Maybe.withDefault ""
                |> parseFormData

        maybeId =
            String.toInt idStr

        maybeRule =
            Dict.get "rule" formData

        maybeInterval =
            Dict.get "interval" formData
                |> Maybe.andThen String.toInt
    in
    when { id = maybeId, rule = maybeRule, interval = maybeInterval } is
        { id = Just id, rule = Just rule, interval = Just interval } ->
            { model = model
            , command =
                Rule.updateRule model.dbConnection
                    { id = Rule.ruleIdFromInt id
                    , rule = rule
                    , interval = interval
                    }
                    |> Task.attempt (\result -> RuleUpdated { response = response, result = result })
            }

        _ ->
            { model = model
            , command = sendError response 400 "Missing required fields"
            }



-- FORM DATA PARSING


parseFormData : String -> Dict String String
parseFormData body =
    let
        decodeFormValue str =
            str
                |> String.replace "+" " "
                |> Url.percentDecode
                |> Maybe.withDefault str
    in
    body
        |> String.split "&"
        |> Array.foldl
            (\pair acc ->
                when String.split "=" pair is
                    [ key, value ] ->
                        Dict.set (decodeFormValue key) (decodeFormValue value) acc

                    _ ->
                        acc
            )
            Dict.empty



-- RESPONSE HELPERS


sendHtml : Response -> String -> Cmd Msg
sendHtml response html =
    response
        |> Response.setHeader "Content-Type" "text/html; charset=utf-8"
        |> Response.setBody html
        |> Response.send


sendError : Response -> Int -> String -> Cmd Msg
sendError response status message =
    response
        |> Response.setStatus status
        |> Response.setHeader "Content-Type" "text/html; charset=utf-8"
        |> Response.setBody (errorPage status message)
        |> Response.send


redirect : Response -> String -> Cmd Msg
redirect response path =
    response
        |> Response.setStatus 303
        |> Response.setHeader "Location" path
        |> Response.send



-- TIME FORMATTING


-- TODO: Make time zone dynamic (e.g., from user preferences or browser)
easternTime : Time.Zone
easternTime =
    Time.customZone (-5 * 60) []


formatDateTime : Time.Zone -> Time.Posix -> String
formatDateTime zone posix =
    let
        month =
            monthToInt (Time.toMonth zone posix)

        day =
            Time.toDay zone posix

        year =
            Time.toYear zone posix

        hour24 =
            Time.toHour zone posix

        minute =
            Time.toMinute zone posix

        hour12 =
            let
                h = Math.remainderBy 12 hour24
            in
            if h == 0 then 12 else h

        amPm =
            if hour24 < 12 then "am" else "pm"

        pad n =
            if n < 10 then
                "0" ++ String.fromInt n

            else
                String.fromInt n
    in
    String.fromInt month
        ++ "/"
        ++ String.fromInt day
        ++ "/"
        ++ String.fromInt year
        ++ " "
        ++ String.fromInt hour12
        ++ ":"
        ++ pad minute
        ++ amPm


monthToInt : Time.Month -> Int
monthToInt month =
    when month is
        Time.Jan -> 1
        Time.Feb -> 2
        Time.Mar -> 3
        Time.Apr -> 4
        Time.May -> 5
        Time.Jun -> 6
        Time.Jul -> 7
        Time.Aug -> 8
        Time.Sep -> 9
        Time.Oct -> 10
        Time.Nov -> 11
        Time.Dec -> 12



-- VIEWS


layout : { title : String, body : Array (Html msg) } -> String
layout config =
    "<!DOCTYPE html>"
        ++ H.toString
            (H.html []
                [ H.head []
                    [ H.meta [ A.charset "utf-8" ]
                    , H.meta
                        [ A.name "viewport"
                        , A.content "width=device-width, initial-scale=1"
                        ]
                    , H.title [ H.text config.title ]
                    , H.link
                        [ A.rel "stylesheet"
                        , A.href "https://cdn.jsdelivr.net/npm/kelpui@1/css/kelp.css"
                        ]
                    , H.link
                        [ A.rel "stylesheet"
                        , A.href "/styles.css"
                        ]
                    ]
                , H.body []
                    [ H.main_ [ A.class "container-l stack" ] config.body
                    ]
                ]
            )


homePage : Maybe Rule -> String
homePage maybeRule =
    layout
        { title = "Growth"
        , body =
            [ H.h1 [] [ H.text "Growth" ]
            , when maybeRule is
                Just rule ->
                    H.div [ A.class "stack" ]
                        [ H.div [ A.class "callout" ]
                            [ H.p [] [ H.text rule.rule ]
                            ]
                        , H.p [] [ H.text "How well have you been remembering this?" ]
                        , H.div [ A.class "cluster" ]
                            [ H.form
                                [ A.method "post"
                                , A.action ("/rules/" ++ String.fromInt (Rule.ruleIdToInt rule.id) ++ "/good")
                                ]
                                [ H.button [ A.type_ "submit", A.class "primary" ] [ H.text "So good" ]
                                ]
                            , H.form
                                [ A.method "post"
                                , A.action ("/rules/" ++ String.fromInt (Rule.ruleIdToInt rule.id) ++ "/again")
                                ]
                                [ H.button [ A.type_ "submit", A.class "outline" ] [ H.text "No good" ]
                                ]
                            ]
                        ]

                Nothing ->
                    H.p [] [ H.text "All done for now!" ]
            , H.nav []
                [ H.a [ A.href "/rules", A.class "link-subtle" ] [ H.text "Manage Rules" ]
                ]
            ]
        }


rulesListPage : Array Rule -> String
rulesListPage rules =
    layout
        { title = "Rules - Growth"
        , body =
            [ H.header [ A.class "stack gap-4xs" ]
                [ H.a [ A.href "/", A.class "link-subtle" ] [ H.text "â† Home" ]
                , H.h1 [] [ H.text "Rules" ]
                ]
            , H.section [ A.class "stack" ]
                [ H.h2 [] [ H.text "Add New Rule" ]
                , ruleForm Nothing
                ]
            , H.hr [] []
            , H.section [ A.class "stack" ]
                [ H.h2 [] [ H.text "Current Rules" ]
                , if Array.isEmpty rules then
                    H.p [] [ H.text "No rules yet. Add one above!" ]
                  else
                    H.table [ A.class "table-striped" ] 
                        [ H.tbody [] (Array.map ruleItem rules) ]
                ]
            ]
        }


ruleItem : Rule -> Html msg
ruleItem rule =
    let
        idStr =
            String.fromInt (Rule.ruleIdToInt rule.id)
    in
    H.tr []
        [ H.td [] [ H.text rule.rule ]
        , H.td [ A.style "white-space" "nowrap" ] [ H.small [ A.class "muted" ] [ H.text ("Interval: " ++ String.fromInt rule.interval) ] ]
        , H.td [ A.style "white-space" "nowrap" ] [ H.small [ A.class "muted" ] [ H.text ("Show: " ++ formatDateTime easternTime rule.showAgain) ] ]
        , H.td [ A.class "cluster gap-4xs", A.style "align-items" "center" ]
            [ H.form
                [ A.method "post"
                , A.action ("/rules/" ++ idStr ++ "/delete")
                , A.style "display" "inline"
                , A.style "white-space" "nowrap"
                ]
                [ H.a [ A.href ("/rules/" ++ idStr ++ "/edit"), A.class "btn outline size-xs" ] [ H.text "Edit" ]
                , H.button [ A.type_ "submit", A.class "danger size-xs" ] [ H.text "Delete" ]
                ]
            ]
        ]


ruleForm : Maybe Rule -> Html msg
ruleForm maybeRule =
    let
        action =
            when maybeRule is
                Nothing ->
                    "/rules"

                Just rule ->
                    "/rules/" ++ String.fromInt (Rule.ruleIdToInt rule.id)

        ruleValue =
            maybeRule
                |> Maybe.map .rule
                |> Maybe.withDefault ""

        intervalValue =
            maybeRule
                |> Maybe.map (.interval >> String.fromInt)
                |> Maybe.withDefault "1"

        buttonText =
            when maybeRule is
                Nothing ->
                    "Add Rule"

                Just _ ->
                    "Update Rule"
    in
    H.form [ A.method "post", A.action action, A.class "stack" ]
        [ H.div []
            [ H.label [ A.for "rule" ] [ H.text "Rule" ]
            , H.input
                [ A.type_ "text"
                , A.name "rule"
                , A.id "rule"
                , A.value ruleValue
                , A.attribute "required" "required"
                ]
                []
            ]
        , H.div []
            [ H.label [ A.for "interval" ] [ H.text "Interval" ]
            , H.input
                [ A.type_ "number"
                , A.name "interval"
                , A.id "interval"
                , A.value intervalValue
                , A.attribute "min" "1"
                , A.attribute "required" "required"
                , A.style "width" "5rem"
                ]
                []
            ]
        , H.div []
            [ H.button [ A.type_ "submit", A.class "primary" ] [ H.text buttonText ]
            ]
        ]


editRulePage : Rule -> String
editRulePage rule =
    layout
        { title = "Edit Rule - Growth"
        , body =
            [ H.header [ A.class "cluster" ]
                [ H.h1 [] [ H.text "Edit Rule" ]
                , H.a [ A.href "/rules", A.class "link-subtle" ] [ H.text "Back to Rules" ]
                ]
            , ruleForm (Just rule)
            ]
        }


errorPage : Int -> String -> String
errorPage status message =
    layout
        { title = "Error - Growth"
        , body =
            [ H.h1 [] [ H.text ("Error " ++ String.fromInt status) ]
            , H.div [ A.class "callout danger" ]
                [ H.p [] [ H.text message ]
                ]
            , H.p [] [ H.a [ A.href "/", A.class "link-subtle" ] [ H.text "Back to Home" ] ]
            ]
        }



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    when model.server is
        Just server ->
            HttpServer.onRequest server
                (\req res -> GotRequest { request = req, response = res })

        Nothing ->
            Sub.none
