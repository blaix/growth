module Rule exposing
    ( Rule
    , RuleId
    , ruleIdFromInt
    , ruleIdToInt
    , getAllRules
    , getRule
    , getNextDueRule
    , createRule
    , updateRule
    , deleteRule
    , markRuleGood
    , markRuleAgain
    )

import Array exposing (Array)
import Db
import Db.Decode as Decode
import Db.Encode as Encode
import Task exposing (Task)
import Time


type RuleId
    = RuleId Int


ruleIdFromInt : Int -> RuleId
ruleIdFromInt id =
    RuleId id


ruleIdToInt : RuleId -> Int
ruleIdToInt (RuleId id) =
    id


type alias Rule =
    { id : RuleId
    , rule : String
    , interval : Int
    , showAgain : Time.Posix
    }



-- READ


getAllRules : Db.Connection -> Task Db.Error (Array Rule)
getAllRules connection =
    Db.getAll connection
        { query = "SELECT id, rule, interval, show_again FROM rules ORDER BY rule ASC"
        , parameters = []
        , decoder = ruleDecoder
        }


getRule : Db.Connection -> RuleId -> Task Db.Error (Maybe Rule)
getRule connection ruleId =
    Db.getMaybeOne connection
        { query = "SELECT id, rule, interval, show_again FROM rules WHERE id = :id"
        , parameters = [ Encode.int "id" (ruleIdToInt ruleId) ]
        , decoder = ruleDecoder
        }


getNextDueRule : Db.Connection -> Time.Posix -> Task Db.Error (Maybe Rule)
getNextDueRule connection now =
    Db.getMaybeOne connection
        { query = """
            SELECT id, rule, interval, show_again
            FROM rules
            WHERE show_again <= :now
            ORDER BY show_again ASC
            LIMIT 1
            """
        , parameters = [ Encode.posix "now" now ]
        , decoder = ruleDecoder
        }



-- WRITE


createRule : Db.Connection -> Time.Posix -> { rule : String, interval : Int } -> Task Db.Error {}
createRule connection now newRule =
    let
        showAgain =
            Time.posixToMillis now + (newRule.interval * 3600 * 1000)
                |> Time.millisToPosix
    in
    Db.execute connection
        { statement = "INSERT INTO rules (rule, interval, show_again) VALUES (:rule, :interval, :showAgain)"
        , parameters =
            [ Encode.string "rule" newRule.rule
            , Encode.int "interval" newRule.interval
            , Encode.posix "showAgain" showAgain
            ]
        }
        |> Task.map (\_ -> {})


updateRule : Db.Connection -> { id : RuleId, rule : String, interval : Int } -> Task Db.Error {}
updateRule connection rule =
    Db.execute connection
        { statement = "UPDATE rules SET rule = :rule, interval = :interval WHERE id = :id"
        , parameters =
            [ Encode.int "id" (ruleIdToInt rule.id)
            , Encode.string "rule" rule.rule
            , Encode.int "interval" rule.interval
            ]
        }
        |> Task.map (\_ -> {})


deleteRule : Db.Connection -> RuleId -> Task Db.Error {}
deleteRule connection ruleId =
    Db.execute connection
        { statement = "DELETE FROM rules WHERE id = :id"
        , parameters = [ Encode.int "id" (ruleIdToInt ruleId) ]
        }
        |> Task.map (\_ -> {})


markRuleGood : Db.Connection -> Time.Posix -> RuleId -> Task Db.Error {}
markRuleGood connection now ruleId =
    getRule connection ruleId
        |> Task.andThen
            (\maybeRule ->
                when maybeRule is
                    Just rule ->
                        let
                            newInterval =
                                rule.interval + 2

                            showAgain =
                                Time.posixToMillis now + (newInterval * 3600 * 1000)
                                    |> Time.millisToPosix
                        in
                        Db.execute connection
                            { statement = "UPDATE rules SET interval = :interval, show_again = :showAgain WHERE id = :id"
                            , parameters =
                                [ Encode.int "id" (ruleIdToInt ruleId)
                                , Encode.int "interval" newInterval
                                , Encode.posix "showAgain" showAgain
                                ]
                            }
                            |> Task.map (\_ -> {})

                    Nothing ->
                        Task.succeed {}
            )


markRuleAgain : Db.Connection -> Time.Posix -> RuleId -> Task Db.Error {}
markRuleAgain connection now ruleId =
    getRule connection ruleId
        |> Task.andThen
            (\maybeRule ->
                when maybeRule is
                    Just rule ->
                        let
                            newInterval =
                                max 1 (rule.interval - 1)

                            showAgain =
                                Time.posixToMillis now + (newInterval * 3600 * 1000)
                                    |> Time.millisToPosix
                        in
                        Db.execute connection
                            { statement = "UPDATE rules SET interval = :interval, show_again = :showAgain WHERE id = :id"
                            , parameters =
                                [ Encode.int "id" (ruleIdToInt ruleId)
                                , Encode.int "interval" newInterval
                                , Encode.posix "showAgain" showAgain
                                ]
                            }
                            |> Task.map (\_ -> {})

                    Nothing ->
                        Task.succeed {}
            )



-- DECODER


ruleDecoder : Decode.Decoder Rule
ruleDecoder =
    Decode.field Decode.int "id" <| \id ->
    Decode.field Decode.string "rule" <| \rule ->
    Decode.field Decode.int "interval" <| \interval ->
    Decode.field Decode.posix "show_again" <| \showAgain ->
    Decode.succeed
        { id = ruleIdFromInt id
        , rule = rule
        , interval = interval
        , showAgain = showAgain
        }
